diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 1c98d781a..1facd540b 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -47,6 +47,7 @@ source "drivers/net/wireless/st/Kconfig"
 source "drivers/net/wireless/ti/Kconfig"
 source "drivers/net/wireless/zydas/Kconfig"
 source "drivers/net/wireless/quantenna/Kconfig"
+source "drivers/net/wireless/esp32/Kconfig"
 
 config PCMCIA_RAYCS
 	tristate "Aviator/Raytheon 2.4GHz wireless support"
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 6cfe74515..2ef89d567 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_WLAN_VENDOR_ST) += st/
 obj-$(CONFIG_WLAN_VENDOR_TI) += ti/
 obj-$(CONFIG_WLAN_VENDOR_ZYDAS) += zydas/
 obj-$(CONFIG_WLAN_VENDOR_QUANTENNA) += quantenna/
+obj-$(CONFIG_ESP32_SDIO) += esp32/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
diff --git a/drivers/net/wireless/esp32/Kconfig b/drivers/net/wireless/esp32/Kconfig
new file mode 100755
index 000000000..59efcd903
--- /dev/null
+++ b/drivers/net/wireless/esp32/Kconfig
@@ -0,0 +1,22 @@
+config ESP32_SDIO
+	tristate "Espressif ESP32 SDIO WiFi"
+	depends on MAC80211
+	select BT
+	select BT_HCIUART
+	---help---
+	  ESP32 is a low-budget 2.4GHz WiFi chip by Espressif, used in many
+	  cheap tablets with Allwinner or Rockchip SoC
+
+config SUPPORT_ESP_SERIAL
+	bool "Enable serial support for ESP32"
+	depends on ESP32_SDIO
+	default n
+	---help---
+	  serial process support for ESP32
+
+config ENABLE_MONITOR_PROCESS
+	bool "Enable monitor process support for ESP32"
+	depends on ESP32_SDIO
+	default n
+	---help---
+	  monitor process support for ESP32
\ No newline at end of file
diff --git a/drivers/net/wireless/esp32/LICENSE b/drivers/net/wireless/esp32/LICENSE
new file mode 100755
index 000000000..d6a93266f
--- /dev/null
+++ b/drivers/net/wireless/esp32/LICENSE
@@ -0,0 +1,340 @@
+GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    {description}
+    Copyright (C) {year}  {fullname}
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  {signature of Ty Coon}, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
+
diff --git a/drivers/net/wireless/esp32/Makefile b/drivers/net/wireless/esp32/Makefile
new file mode 100755
index 000000000..be181eb37
--- /dev/null
+++ b/drivers/net/wireless/esp32/Makefile
@@ -0,0 +1,15 @@
+MODULE_NAME = esp32_sdio
+
+ifeq ($(CONFIG_SUPPORT_ESP_SERIAL), y)
+	EXTRA_CFLAGS += -DCONFIG_SUPPORT_ESP_SERIAL
+endif
+
+ifeq ($(CONFIG_ENABLE_MONITOR_PROCESS), y)
+	EXTRA_CFLAGS += -DCONFIG_ENABLE_MONITOR_PROCESS
+endif
+
+EXTRA_CFLAGS += -I$(PWD)
+
+$(MODULE_NAME)-y := esp_bt.o main.o esp_sdio.o esp_sdio_api.o esp_serial.o esp_rb.o
+
+obj-$(CONFIG_ESP32_SDIO) += esp32_sdio.o
diff --git a/drivers/net/wireless/esp32/adapter.h b/drivers/net/wireless/esp32/adapter.h
new file mode 100755
index 000000000..7979b31c4
--- /dev/null
+++ b/drivers/net/wireless/esp32/adapter.h
@@ -0,0 +1,66 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+/* SPDX-License-Identifier: GPL-2.0 OR Apache-2.0 */
+
+#ifndef __ESP_NETWORK_ADAPTER__H
+#define __ESP_NETWORK_ADAPTER__H
+
+struct esp_payload_header {
+	uint8_t 		 if_type:4;
+	uint8_t 		 if_num:4;
+	uint8_t			 reserved1;
+	uint16_t                 len;
+	uint16_t                 offset;
+	uint8_t                  reserved2;
+	union {
+		uint8_t		 reserved3;
+		uint8_t		 hci_pkt_type;		/* Packet type for HCI interface */
+		uint8_t		 priv_pkt_type;		/* Packet type for priv interface */
+	};
+} __attribute__((packed));
+
+typedef enum {
+	ESP_STA_IF,
+	ESP_AP_IF,
+	ESP_SERIAL_IF,
+	ESP_HCI_IF,
+	ESP_PRIV_IF,
+	ESP_MAX_IF,
+} ESP_INTERFACE_TYPE;
+
+typedef enum {
+	ESP_OPEN_DATA_PATH,
+	ESP_CLOSE_DATA_PATH,
+	ESP_RESET,
+} ESP_HOST_INTERRUPT;
+
+
+typedef enum {
+	ESP_WLAN_SDIO_SUPPORT = (1 << 0),
+	ESP_BT_UART_SUPPORT = (1 << 1),
+	ESP_BT_SDIO_SUPPORT = (1 << 2),
+	ESP_BLE_ONLY_SUPPORT = (1 << 3),
+	ESP_BR_EDR_ONLY_SUPPORT = (1 << 4),
+	ESP_WLAN_SPI_SUPPORT = (1 << 5),
+	ESP_BT_SPI_SUPPORT = (1 << 6),
+} ESP_CAPABILITIES;
+
+typedef enum {
+	ESP_PACKET_TYPE_EVENT,
+} ESP_PRIV_PACKET_TYPE;
+
+typedef enum {
+	ESP_PRIV_EVENT_INIT,
+} ESP_PRIV_EVENT_TYPE;
+
+typedef enum {
+	ESP_PRIV_CAPABILITY,
+	ESP_PRIV_SPI_CLK_MHZ,
+	ESP_PRIV_FIRMWARE_CHIP_ID,
+} ESP_PRIV_TAG_TYPE;
+
+struct esp_priv_event {
+	uint8_t		event_type;
+	uint8_t		event_len;
+	uint8_t		event_data[0];
+}__attribute__((packed));
+#endif
diff --git a/drivers/net/wireless/esp32/esp.h b/drivers/net/wireless/esp32/esp.h
new file mode 100755
index 000000000..939068498
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp.h
@@ -0,0 +1,92 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __esp__h_
+#define __esp__h_
+
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include "adapter.h"
+
+#define ESP_IF_TYPE_SDIO		1
+#define ESP_IF_TYPE_SPI		2
+
+/* Network link status */
+#define ESP_LINK_DOWN			0
+#define ESP_LINK_UP			1
+
+#define ESP_MAX_INTERFACE		2
+
+#define ESP_PAYLOAD_HEADER		8
+struct esp_private;
+struct esp_adapter;
+
+#define ACQUIRE_LOCK			1
+#define LOCK_ALREADY_ACQUIRED		0
+
+struct esp_adapter {
+	u8				if_type;
+	u32				capabilities;
+
+	/* Possible types:
+	 * 	struct esp_sdio_context */
+	void				*if_context;
+
+	struct esp_if_ops		*if_ops;
+
+	/* Private for each interface */
+	struct esp_private		*priv[ESP_MAX_INTERFACE];
+	struct hci_dev 			*hcidev;
+
+	struct workqueue_struct 	*if_rx_workqueue;
+	struct work_struct		if_rx_work;
+
+	/* Process TX work */
+	struct workqueue_struct 	*tx_workqueue;
+	struct work_struct		tx_work;
+
+	/* TX queue */
+	struct sk_buff_head 		tx_q;
+
+	/* RX Queue */
+	struct sk_buff_head 		rx_q;
+
+	/* Counters */
+	atomic_t			tx_pending;
+	atomic_t			rx_pending;
+};
+
+
+struct esp_private {
+	struct esp_adapter		*adapter;
+	struct net_device		*ndev;
+	struct net_device_stats 	stats;
+	u8				link_state;
+	u8				mac_address[6];
+	u8 				if_type;
+	u8			 	if_num;
+};
+
+struct esp_skb_cb {
+	struct esp_private		*priv;
+};
+#endif
diff --git a/drivers/net/wireless/esp32/esp_api.h b/drivers/net/wireless/esp32/esp_api.h
new file mode 100755
index 000000000..5f88cd3b3
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_api.h
@@ -0,0 +1,33 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _esp_api__h_
+#define _esp_api__h_
+
+#include "esp.h"
+
+int esp_add_card(struct esp_adapter *adapter);
+int esp_remove_card(struct esp_adapter *adapter);
+void esp_process_new_packet_intr(struct esp_adapter *adapter);
+struct esp_adapter * esp_get_adapter(void);
+struct sk_buff * esp_alloc_skb(u32 len);
+int esp_send_packet(struct esp_adapter *adapter, u8 *buf, u32 size);
+u8 esp_is_bt_supported_over_sdio(u32 cap);
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_bt.c b/drivers/net/wireless/esp32/esp_bt.c
new file mode 100755
index 000000000..6fa46b5bd
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_bt.c
@@ -0,0 +1,217 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#include "esp_bt_api.h"
+#include "esp_api.h"
+
+#define INVALID_HDEV_BUS (0xff)
+
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (hdev) {
+		if (pkt_type == HCI_COMMAND_PKT) {
+			hdev->stat.cmd_tx++;
+		} else if (pkt_type == HCI_ACLDATA_PKT) {
+			hdev->stat.acl_tx++;
+		} else if (pkt_type == HCI_SCODATA_PKT) {
+			hdev->stat.sco_tx++;
+		}
+
+		hdev->stat.byte_tx += len;
+	}
+}
+
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (hdev) {
+		if (pkt_type == HCI_EVENT_PKT) {
+			hdev->stat.evt_rx++;
+		} else if (pkt_type == HCI_ACLDATA_PKT) {
+			hdev->stat.acl_rx++;
+		} else if (pkt_type == HCI_SCODATA_PKT) {
+			hdev->stat.sco_rx++;
+		}
+
+		hdev->stat.byte_rx += len;
+	}
+}
+
+static int esp_bt_open(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_close(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_flush(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	struct esp_payload_header *hdr;
+	size_t total_len, len = skb->len;
+	int ret = 0;
+	struct esp_adapter *adapter = hci_get_drvdata(hdev);
+	struct sk_buff *new_skb;
+
+	if (!adapter) {
+		printk(KERN_ERR "%s: invalid args", __func__);
+		return -EINVAL;
+	}
+
+	total_len = len + sizeof(struct esp_payload_header);
+
+	if (skb_headroom(skb) < sizeof(struct esp_payload_header)) {
+		/* insufficent headroom to add payload header */
+		new_skb = skb_realloc_headroom(skb, sizeof(struct esp_payload_header));
+
+		if(!new_skb) {
+			printk(KERN_ERR "%s: Failed to allocate SKB", __func__);
+			dev_kfree_skb(skb);
+			hdev->stat.err_tx++;
+			return -ENOMEM;
+		}
+
+		dev_kfree_skb(skb);
+
+		skb = new_skb;
+	}
+
+	skb_push(skb, sizeof(struct esp_payload_header));
+
+	hdr = (struct esp_payload_header *) skb->data;
+
+	memset (hdr, 0, sizeof(struct esp_payload_header));
+
+	hdr->if_type = ESP_HCI_IF;
+	hdr->if_num = 0;
+	hdr->len = cpu_to_le16(len);
+	hdr->offset = cpu_to_le16(sizeof(struct esp_payload_header));
+	hdr->hci_pkt_type = hci_skb_pkt_type(skb);
+
+	ret = esp_send_packet(adapter, skb->data, skb->len);
+
+	if (ret) {
+		hdev->stat.err_tx++;
+	} else {
+		esp_hci_update_tx_counter(hdev, hdr->hci_pkt_type, skb->len);
+	}
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static int esp_bt_setup(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)
+{
+	return 0;
+}
+
+int esp_deinit_bt(struct esp_adapter *adapter)
+{
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter || !adapter->hcidev)
+		return 0;
+
+	hdev = adapter->hcidev;
+
+	hci_unregister_dev(hdev);
+	hci_free_dev(hdev);
+
+	adapter->hcidev = NULL;
+
+	return 0;
+}
+
+int esp_init_bt(struct esp_adapter *adapter)
+{
+	int ret = 0;
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter) {
+		return -EINVAL;
+	}
+
+	if (adapter->hcidev) {
+		return -EEXIST;
+	}
+
+	hdev = hci_alloc_dev();
+
+	if (!hdev) {
+		BT_ERR("Can not allocate HCI device");
+		return -ENOMEM;
+	}
+
+	adapter->hcidev = hdev;
+	hci_set_drvdata(hdev, adapter);
+
+	hdev->bus = INVALID_HDEV_BUS;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19))
+	if (adapter->if_type == ESP_IF_TYPE_SDIO)
+		hdev->bus   = HCI_SDIO;
+  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	else if (adapter->if_type == ESP_IF_TYPE_SPI)
+		hdev->bus   = HCI_SPI;
+  #endif
+#endif
+
+	if (hdev->bus == INVALID_HDEV_BUS) {
+
+		if (adapter->if_type == ESP_IF_TYPE_SDIO) {
+			printk(KERN_ERR "%s: Kernel version does not support HCI over SDIO BUS\n",__func__);
+		} else if (adapter->if_type == ESP_IF_TYPE_SPI) {
+			printk(KERN_ERR "%s: Kernel version does not support HCI over SPI BUS\n",__func__);
+		} else {
+			printk(KERN_ERR "%s: HCI over expected BUS[%u] is not supported\n",__func__, adapter->if_type);
+		}
+		hci_free_dev(hdev);
+		adapter->hcidev = NULL;
+		return -EINVAL;
+	}
+
+	hdev->open  = esp_bt_open;
+	hdev->close = esp_bt_close;
+	hdev->flush = esp_bt_flush;
+	hdev->send  = esp_bt_send_frame;
+	hdev->setup = esp_bt_setup;
+	hdev->set_bdaddr = esp_bt_set_bdaddr;
+
+	hdev->dev_type = HCI_PRIMARY;
+
+	ret = hci_register_dev(hdev);
+	if (ret < 0) {
+		BT_ERR("Can not register HCI device");
+		hci_free_dev(hdev);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/esp32/esp_bt_api.h b/drivers/net/wireless/esp32/esp_bt_api.h
new file mode 100755
index 000000000..d2cc2318d
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_bt_api.h
@@ -0,0 +1,48 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __esp_bt_api_h_
+#define __esp_bt_api_h_
+
+#include <linux/version.h>
+#include "esp.h"
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14))
+		#define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
+	#else
+		#error "No symbol bt_cb((skb))->pkt_type in kernel < 2.6.14"
+	#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)) 
+		#define HCI_PRIMARY HCI_BREDR
+	#else
+		#error "No symbol HCI_BREDR found in kernel < 2.6.34"
+	#endif
+#endif
+
+int esp_init_bt(struct esp_adapter *adapter);
+int esp_deinit_bt(struct esp_adapter *adapter);
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_if.h b/drivers/net/wireless/esp32/esp_if.h
new file mode 100755
index 000000000..3dcb2e0f4
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_if.h
@@ -0,0 +1,35 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __ESP_IF__H_
+#define __ESP_IF__H_
+
+#include "esp.h"
+
+struct esp_if_ops {
+	int (*init)(struct esp_adapter *adapter);
+	struct sk_buff* (*read)(struct esp_adapter *adapter);
+	int (*write)(struct esp_adapter *adapter, u8 *buf, u32 size);
+	int (*deinit)(struct esp_adapter *adapter);
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter);
+void esp_deinit_interface_layer(void);
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_rb.c b/drivers/net/wireless/esp32/esp_rb.c
new file mode 100755
index 000000000..370ed85ac
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_rb.c
@@ -0,0 +1,119 @@
+/*
+ * The citation should list that the code comes from the book "Linux Device
+ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
+ * by O'Reilly & Associates.No warranty is attached;
+ *
+ * */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/uaccess.h>
+
+#include "esp_rb.h"
+
+int esp_rb_init(esp_rb_t *rb, size_t sz)
+{
+	init_waitqueue_head(&(rb->wq));
+
+	rb->buf = kmalloc(sz, GFP_KERNEL);
+	if (!rb->buf) {
+		printk(KERN_ERR "Failed to allocate memory for rb\n");
+		return -ENOMEM;
+	}
+
+	rb->end = rb->buf + sz;
+	rb->rp = rb->wp = rb->buf;
+	rb->size = sz;
+
+	sema_init(&(rb->sem), 1);
+	return 0;
+}
+
+ssize_t esp_rb_read_by_user(esp_rb_t *rb, const char __user *buf, size_t sz, int block)
+{
+	if (down_interruptible(&rb->sem)) {
+		return -ERESTARTSYS; /* Signal interruption */
+	}
+
+	while(rb->rp == rb->wp) {
+		up(&rb->sem);
+		if (block == 0) {
+			return -EAGAIN;
+		}
+		if (wait_event_interruptible(rb->wq, (rb->rp != rb->wp))) {
+			return -ERESTARTSYS; /* Signal interruption */
+		}
+		if (down_interruptible(&rb->sem)) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	if (rb->wp > rb->rp) {
+		sz = min(sz, (size_t)(rb->wp - rb->rp));
+	} else {
+		sz = min(sz, (size_t)(rb->end - rb->rp));
+	}
+	if (copy_to_user((void *)buf, rb->rp, sz)) {
+		up(&rb->sem);
+		return -EFAULT;
+	}
+	rb->rp += sz;
+	if (rb->rp == rb->end) {
+		rb->rp = rb->buf;
+	}
+	up(&rb->sem);
+
+	return sz;
+}
+
+size_t get_free_space(esp_rb_t *rb)
+{
+	if (rb->rp == rb->wp) {
+		return rb->size - 1;
+	} else {
+		return ((rb->rp + rb->size - rb->wp) % rb->size) - 1;
+	}
+}
+
+ssize_t esp_rb_write_by_kernel(esp_rb_t *rb, const char *buf, size_t sz)
+{
+	if (down_interruptible(&rb->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	if (get_free_space(rb) == 0) {
+		up(&rb->sem);
+		printk(KERN_ERR "Ringbuffer full, no space to write\n");
+		return 0;
+	}
+
+	sz = min(sz, get_free_space(rb));
+	if (rb->wp >= rb->rp) {
+		sz = min(sz, (size_t)(rb->end - rb->wp));
+	} else {
+		sz = min(sz, (size_t)(rb->rp - rb->wp - 1));
+	}
+
+	memcpy(rb->wp, buf, sz);
+	rb->wp += sz;
+	if (rb->wp == rb->end) {
+		rb->wp = rb->buf;
+	}
+	up(&rb->sem);
+
+	wake_up_interruptible(&rb->wq);
+
+	return sz;
+}
+
+void esp_rb_cleanup(esp_rb_t *rb)
+{
+	kfree(rb->buf);
+	rb->buf = rb->end = rb->rp = rb->wp = NULL;
+	rb->size = 0;
+	return;
+}
diff --git a/drivers/net/wireless/esp32/esp_rb.h b/drivers/net/wireless/esp32/esp_rb.h
new file mode 100755
index 000000000..2a048e340
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_rb.h
@@ -0,0 +1,25 @@
+/*
+ * The citation should list that the code comes from the book "Linux Device
+ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
+ * by O'Reilly & Associates.No warranty is attached;
+ *
+ * */
+
+#ifndef _ESP_RB_H_
+#define _ESP_RB_H_
+
+typedef struct esp_rb {
+	wait_queue_head_t wq;		/* waitqueue to wait for data */
+	unsigned char *buf, *end;	/* actual queue start and end */
+	size_t size;
+	unsigned char *rp, *wp;		/* current read/write pointers */
+	struct semaphore sem;		/* Mutex to protect rb */
+} esp_rb_t;
+
+int esp_rb_init(esp_rb_t *rb, size_t sz);
+void esp_rb_cleanup(esp_rb_t *rb);
+ssize_t esp_rb_read_by_user(esp_rb_t *rb, const char __user *buf, size_t sz, int block);
+ssize_t esp_rb_write_by_kernel(esp_rb_t *rb, const char *buf, size_t sz);
+size_t get_free_space(esp_rb_t *rb);
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_sdio.c b/drivers/net/wireless/esp32/esp_sdio.c
new file mode 100755
index 000000000..2d68270a0
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_sdio.c
@@ -0,0 +1,641 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/mutex.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "esp_if.h"
+#include "esp_sdio_api.h"
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+#include "esp_serial.h"
+#endif
+#include <linux/kthread.h>
+
+#define CHECK_SDIO_RW_ERROR(ret) do {			\
+	if (ret)						\
+	printk(KERN_ERR "%s: CMD53 read/write error at %d\n", __func__, __LINE__);	\
+} while (0);
+
+struct esp_sdio_context sdio_context;
+
+#ifdef CONFIG_ENABLE_MONITOR_PROCESS
+struct task_struct *monitor_thread;
+#endif
+
+static int init_context(struct esp_sdio_context *context);
+static struct sk_buff * read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, u8 *buf, u32 size);
+/*int deinit_context(struct esp_adapter *adapter);*/
+
+static const struct sdio_device_id esp_devices[] = {
+	{ SDIO_DEVICE(ESP_VENDOR_ID, ESP_DEVICE_ID_1) },
+	{ SDIO_DEVICE(ESP_VENDOR_ID, ESP_DEVICE_ID_2) },
+	{}
+};
+
+static void print_capabilities(u32 cap)
+{
+	printk(KERN_INFO "Features supported are:\n");
+	if (cap & ESP_WLAN_SDIO_SUPPORT)
+		printk(KERN_INFO "\t * WLAN\n");
+	if ((cap & ESP_BT_UART_SUPPORT) || (cap & ESP_BT_SDIO_SUPPORT)) {
+		printk(KERN_INFO "\t * BT/BLE\n");
+		if (cap & ESP_BT_UART_SUPPORT)
+			printk(KERN_INFO "\t   - HCI over UART\n");
+		if (cap & ESP_BT_SDIO_SUPPORT)
+			printk(KERN_INFO "\t   - HCI over SDIO\n");
+
+		if ((cap & ESP_BLE_ONLY_SUPPORT) && (cap & ESP_BR_EDR_ONLY_SUPPORT))
+			printk(KERN_INFO "\t   - BT/BLE dual mode\n");
+		else if (cap & ESP_BLE_ONLY_SUPPORT)
+			printk(KERN_INFO "\t   - BLE only\n");
+		else if (cap & ESP_BR_EDR_ONLY_SUPPORT)
+			printk(KERN_INFO "\t   - BR EDR only\n");
+	}
+}
+
+static void esp_process_interrupt(struct esp_sdio_context *context, u32 int_status)
+{
+	if (!context) {
+		return;
+	}
+
+	if (int_status & ESP_SLAVE_RX_NEW_PACKET_INT) {
+		esp_process_new_packet_intr(context->adapter);
+	}
+}
+
+static void esp_handle_isr(struct sdio_func *func)
+{
+	struct esp_sdio_context *context = NULL;
+	u32 int_status = 0;
+	int ret;
+
+	if (!func) {
+		return;
+	}
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		return;
+	}
+
+	/* Read interrupt status register */
+	ret = esp_read_reg(context, ESP_SLAVE_INT_ST_REG,
+			(u8 *) &int_status, sizeof(int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+
+	esp_process_interrupt(context, int_status);
+
+	/* Clear interrupt status */
+	ret = esp_write_reg(context, ESP_SLAVE_INT_CLR_REG,
+			(u8 *) &int_status, sizeof(int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+}
+
+int generate_slave_intr(struct esp_sdio_context *context, u8 data)
+{
+	if (!context)
+		return -EINVAL;
+
+	return esp_write_reg(context, ESP_SLAVE_SCRATCH_REG_7, &data,
+			sizeof(data), ACQUIRE_LOCK);
+}
+
+static void deinit_sdio_func(struct sdio_func *func)
+{
+	sdio_claim_host(func);
+	/* Release IRQ */
+	sdio_release_irq(func);
+	/* Disable sdio function */
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	sdio_set_drvdata(func, NULL);
+}
+
+static int esp_slave_get_tx_buffer_num(struct esp_sdio_context *context, u32 *tx_num, u8 is_lock_needed)
+{
+    u32 len;
+    int ret = 0;
+
+    ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (uint8_t*)&len, 4, is_lock_needed);
+
+    if (ret)
+	    return ret;
+
+    len = (len >> 16) & ESP_TX_BUFFER_MASK;
+    len = (len + ESP_TX_BUFFER_MAX - context->tx_buffer_count) % ESP_TX_BUFFER_MAX;
+
+    *tx_num = len;
+
+    return ret;
+}
+
+static int esp_get_len_from_slave(struct esp_sdio_context *context, u32 *rx_size, u8 is_lock_needed)
+{
+    u32 len, temp;
+    int ret = 0;
+
+    ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+		    (u8 *) &len, sizeof(len), is_lock_needed);
+
+    if (ret)
+	    return ret;
+
+    len &= ESP_SLAVE_LEN_MASK;
+
+    if (len >= context->rx_byte_count)
+	    len = (len + ESP_RX_BYTE_MAX - context->rx_byte_count) % ESP_RX_BYTE_MAX;
+    else {
+	    /* Handle a case of roll over */
+	    temp = ESP_RX_BYTE_MAX - context->rx_byte_count;
+	    len = temp + len;
+
+	    if (len > ESP_RX_BUFFER_SIZE) {
+		    printk(KERN_INFO "%s: Len from slave[%d] exceeds max [%d]\n",
+				    __func__, len, ESP_RX_BUFFER_SIZE);
+	    }
+    }
+    *rx_size = len;
+
+    return 0;
+}
+
+
+static void flush_sdio(struct esp_sdio_context *context)
+{
+	struct sk_buff *skb;
+
+	if (!context || !context->adapter)
+		return;
+
+	while (1) {
+		skb = read_packet(context->adapter);
+
+		if (!skb) {
+			break;
+		}
+
+		if (skb->len)
+			printk (KERN_INFO "%s: Flushed %d bytes\n", __func__, skb->len);
+		dev_kfree_skb(skb);
+	}
+}
+
+static void esp_remove(struct sdio_func *func)
+{
+	struct esp_sdio_context *context;
+	context = sdio_get_drvdata(func);
+
+	printk(KERN_INFO "%s -> Remove card", __func__);
+
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+	esp_serial_cleanup();
+#endif
+
+#ifdef CONFIG_ENABLE_MONITOR_PROCESS
+	if (monitor_thread)
+		kthread_stop(monitor_thread);
+#endif
+
+	if (context) {
+		generate_slave_intr(context, BIT(ESP_CLOSE_DATA_PATH));
+		msleep(100);
+
+		flush_sdio(context);
+
+		if (context->adapter) {
+			esp_remove_card(context->adapter);
+
+			if (context->adapter->hcidev) {
+				esp_deinit_bt(context->adapter);
+			}
+
+		}
+
+		memset(context, 0, sizeof(struct esp_sdio_context));
+	}
+
+	deinit_sdio_func(func);
+
+	printk (KERN_INFO "%s: Context deinit %d - %d\n", __func__, context->rx_byte_count,
+			context->tx_buffer_count);
+
+}
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static int init_context(struct esp_sdio_context *context)
+{
+	int ret = 0;
+	u32 val = 0;
+
+	if (!context) {
+		return -EINVAL;
+	}
+
+	/* Initialize rx_byte_count */
+	ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+			(u8 *) &val, sizeof(val), ACQUIRE_LOCK);
+	if (ret)
+		return ret;
+
+/*	printk(KERN_DEBUG "%s: LEN %d\n", __func__, (val & ESP_SLAVE_LEN_MASK));*/
+
+	context->rx_byte_count = val & ESP_SLAVE_LEN_MASK;
+
+	/* Initialize tx_buffer_count */
+	ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) &val,
+			sizeof(val), ACQUIRE_LOCK);
+
+	if (ret)
+		return ret;
+
+	val = ((val >> 16) & ESP_TX_BUFFER_MASK);
+
+/*	printk(KERN_DEBUG "%s: BUF_CNT %d\n", __func__, val);*/
+
+	if (val >= ESP_MAX_BUF_CNT)
+		context->tx_buffer_count = val - ESP_MAX_BUF_CNT;
+	else
+		context->tx_buffer_count = 0;
+
+/*	printk(KERN_DEBUG "%s: Context init %d - %d\n", __func__, context->rx_byte_count,*/
+/*			context->tx_buffer_count);*/
+
+	context->adapter = esp_get_adapter();
+
+	if (!context->adapter)
+		printk (KERN_ERR "%s: Failed to get adapter\n", __func__);
+
+	context->adapter->if_type = ESP_IF_TYPE_SDIO;
+
+	return ret;
+}
+
+static struct sk_buff * read_packet(struct esp_adapter *adapter)
+{
+	u32 len_from_slave, data_left, len_to_read, size, num_blocks;
+	int ret = 0;
+	struct sk_buff *skb;
+	u8 *pos;
+	struct esp_sdio_context *context;
+
+	if (!adapter || !adapter->if_context) {
+		printk (KERN_ERR "%s: INVALID args\n", __func__);
+		return NULL;
+	}
+
+	context = adapter->if_context;
+
+	sdio_claim_host(context->func);
+
+	data_left = len_to_read = len_from_slave = num_blocks = 0;
+
+	/* Read length */
+	ret = esp_get_len_from_slave(context, &len_from_slave, LOCK_ALREADY_ACQUIRED);
+
+/*	printk (KERN_DEBUG "LEN FROM SLAVE: %d\n", len_from_slave);*/
+
+	if (ret || !len_from_slave) {
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	size = ESP_BLOCK_SIZE * 4;
+
+	if (len_from_slave > size) {
+		printk(KERN_INFO "Rx large packet: %d\n", len_from_slave);
+	}
+
+	skb = esp_alloc_skb(len_from_slave);
+
+	if (!skb) {
+		printk (KERN_ERR "%s: SKB alloc failed\n", __func__);
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	skb_put(skb, len_from_slave);
+	pos = skb->data;
+
+	data_left = len_from_slave;
+
+	do {
+		num_blocks = data_left/ESP_BLOCK_SIZE;
+
+#if 0
+		if (!context->rx_byte_count) {
+			start_time = ktime_get_ns();
+		}
+#endif
+
+		if (num_blocks) {
+			len_to_read = num_blocks * ESP_BLOCK_SIZE;
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, len_to_read, LOCK_ALREADY_ACQUIRED);
+		} else {
+			len_to_read = data_left;
+			/* 4 byte aligned length */
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, (len_to_read + 3) & (~3), LOCK_ALREADY_ACQUIRED);
+		}
+
+		if (ret) {
+			printk (KERN_ERR "%s: Failed to read data\n", __func__);
+			dev_kfree_skb(skb);
+			sdio_release_host(context->func);
+			return NULL;
+		}
+
+		data_left -= len_to_read;
+		pos += len_to_read;
+		context->rx_byte_count += len_to_read;
+		context->rx_byte_count = context->rx_byte_count % ESP_RX_BYTE_MAX;
+
+	} while (data_left > 0);
+
+	sdio_release_host(context->func);
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, u8 *buf, u32 size)
+{
+	u32 block_cnt = 0, buf_needed = 0;
+	u32 buf_available = 0;
+	int ret = 0;
+	u8 *pos = NULL;
+	u32 data_left, len_to_send, pad;
+	struct esp_sdio_context *context;
+
+	if (!adapter || !adapter->if_context || !buf || !size) {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return -EINVAL;
+	}
+
+	context = adapter->if_context;
+
+	sdio_claim_host(context->func);
+
+	buf_needed = (size + ESP_RX_BUFFER_SIZE - 1) / ESP_RX_BUFFER_SIZE;
+
+	ret = esp_slave_get_tx_buffer_num(context, &buf_available, LOCK_ALREADY_ACQUIRED);
+
+/*	printk(KERN_ERR "%s: TX -> Available [%d], needed [%d]\n", __func__, buf_available, buf_needed);*/
+
+	if (buf_available < buf_needed) {
+		printk(KERN_DEBUG "%s: Not enough buffers available: availabale [%d], needed [%d]\n", __func__,
+				buf_available, buf_needed);
+		sdio_release_host(context->func);
+		return -ENOMEM;
+	}
+
+	pos = buf;
+	data_left = len_to_send = 0;
+
+	data_left = size;
+	pad = ESP_BLOCK_SIZE - (data_left % ESP_BLOCK_SIZE);
+	data_left += pad;
+
+
+	do {
+		block_cnt = data_left / ESP_BLOCK_SIZE;
+		len_to_send = data_left;
+		ret = esp_write_block(context, ESP_SLAVE_CMD53_END_ADDR - len_to_send,
+				pos, (len_to_send + 3) & (~3), LOCK_ALREADY_ACQUIRED);
+
+		if (ret) {
+			printk (KERN_ERR "%s: Failed to send data\n", __func__);
+			sdio_release_host(context->func);
+			return ret;
+		}
+/*		printk (KERN_ERR "--> %d %d %d\n", block_cnt, data_left, len_to_send);*/
+
+		data_left -= len_to_send;
+		pos += len_to_send;
+	} while (data_left);
+
+	context->tx_buffer_count += buf_needed;
+	context->tx_buffer_count = context->tx_buffer_count % ESP_TX_BUFFER_MAX;
+
+	sdio_release_host(context->func);
+
+	return 0;
+}
+
+static struct esp_sdio_context * init_sdio_func(struct sdio_func *func)
+{
+	struct esp_sdio_context *context = NULL;
+	int ret = 0;
+
+	if (!func)
+		return NULL;
+
+	context = &sdio_context;
+
+	context->func = func;
+
+	sdio_claim_host(func);
+
+	/* Enable Function */
+	ret = sdio_enable_func(func);
+	if (ret) {
+		return NULL;
+	}
+
+	/* Register IRQ */
+	ret = sdio_claim_irq(func, esp_handle_isr);
+	if (ret) {
+		sdio_disable_func(func);
+		return NULL;
+	}
+
+	/* Set private data */
+	sdio_set_drvdata(func, context);
+
+	context->state = ESP_CONTEXT_INIT;
+
+	sdio_release_host(func);
+
+	return context;
+}
+
+#ifdef CONFIG_ENABLE_MONITOR_PROCESS
+static int monitor_process(void *data)
+{
+	u32 val, intr, len_reg, rdata, old_len = 0;
+	struct esp_sdio_context *context = (struct esp_sdio_context *) data;
+	struct sk_buff *skb;
+
+	while (!kthread_should_stop()) {
+		msleep(5000);
+
+		val = intr = len_reg = rdata = 0;
+
+		esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+				(u8 *) &val, sizeof(val), ACQUIRE_LOCK);
+
+		len_reg = val & ESP_SLAVE_LEN_MASK;
+
+		val = 0;
+		esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) &val,
+				sizeof(val), ACQUIRE_LOCK);
+
+		rdata = ((val >> 16) & ESP_TX_BUFFER_MASK);
+
+		esp_read_reg(context, ESP_SLAVE_INT_ST_REG,
+				(u8 *) &intr, sizeof(intr), ACQUIRE_LOCK);
+
+
+		if (len_reg > context->rx_byte_count) {
+			if (old_len && (context->rx_byte_count == old_len)) {
+				printk (KERN_DEBUG "Monitor thread ----> [%d - %d] [%d - %d] %d\n",
+						len_reg, context->rx_byte_count,
+						rdata, context->tx_buffer_count, intr);
+
+				skb = read_packet(context->adapter);
+
+				if (!skb)
+					continue;
+
+				if (skb->len)
+					printk (KERN_DEBUG "%s: Flushed %d bytes\n", __func__, skb->len);
+
+				/* drop the packet */
+				dev_kfree_skb(skb);
+			}
+		}
+
+		old_len = context->rx_byte_count;
+	}
+
+	do_exit(0);
+	return 0;
+}
+#endif
+
+static int esp_probe(struct sdio_func *func,
+				  const struct sdio_device_id *id)
+{
+	struct esp_sdio_context *context = NULL;
+	int ret = 0;
+	uint32_t cap = 0;
+
+	if (func->num != 1) {
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s: ESP network device detected\n", __func__);
+
+	context = init_sdio_func(func);
+
+	if (!context) {
+		return -ENOMEM;
+	}
+
+	generate_slave_intr(context, BIT(ESP_RESET));
+
+	msleep(200);
+
+	ret = init_context(context);
+	if (ret) {
+		deinit_sdio_func(func);
+		return ret;
+	}
+
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+	ret = esp_serial_init((void *) context->adapter);
+	if (ret != 0) {
+		esp_remove(func);
+		printk(KERN_ERR "Error initialising serial interface\n");
+		return ret;
+	}
+#endif
+
+	ret = esp_add_card(context->adapter);
+	if (ret) {
+		esp_remove(func);
+		printk (KERN_ERR "Failed to add card\n");
+		deinit_sdio_func(func);
+		return ret;
+	}
+
+	/* Read slave capabilities */
+	esp_read_reg(context, ESP_SLAVE_SCRATCH_REG_0,
+			(u8 *) &cap, sizeof(cap), ACQUIRE_LOCK);
+
+	context->adapter->capabilities = cap;
+
+	print_capabilities(cap);
+
+	if (esp_is_bt_supported_over_sdio(cap)) {
+		esp_init_bt(context->adapter);
+	}
+
+	context->state = ESP_CONTEXT_READY;
+
+#ifdef CONFIG_ENABLE_MONITOR_PROCESS
+	monitor_thread = kthread_run(monitor_process, context, "Monitor process");
+
+	if (!monitor_thread)
+		printk (KERN_ERR "Failed to create monitor thread\n");
+#endif
+
+
+	msleep(200);
+	generate_slave_intr(context, BIT(ESP_OPEN_DATA_PATH));
+	return ret;
+}
+
+/* SDIO driver structure to be registered with kernel */
+static struct sdio_driver esp_sdio_driver = {
+	.name		= "esp_sdio",
+	.id_table	= esp_devices,
+	.probe		= esp_probe,
+	.remove		= esp_remove,
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter)
+{
+	if (!adapter)
+		return -EINVAL;
+
+	adapter->if_context = &sdio_context;
+	adapter->if_ops = &if_ops;
+	sdio_context.adapter = adapter;
+
+	return sdio_register_driver(&esp_sdio_driver);
+}
+
+void esp_deinit_interface_layer(void)
+{
+	sdio_unregister_driver(&esp_sdio_driver);
+}
diff --git a/drivers/net/wireless/esp32/esp_sdio_api.c b/drivers/net/wireless/esp32/esp_sdio_api.c
new file mode 100755
index 000000000..7eff5acb2
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_sdio_api.c
@@ -0,0 +1,160 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "esp_sdio_api.h"
+
+static int esp_read_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	*data = sdio_readb(func, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_byte(struct esp_sdio_context *context, u32 reg, u8 data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	sdio_writeb(func, data, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_read_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_fromio(func, data, reg, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_toio(func, reg, data, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
diff --git a/drivers/net/wireless/esp32/esp_sdio_api.h b/drivers/net/wireless/esp32/esp_sdio_api.h
new file mode 100755
index 000000000..a0a4e2639
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_sdio_api.h
@@ -0,0 +1,29 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _ESP_SDIO_API_H_
+#define _ESP_SDIO_API_H_
+#include "esp_sdio_decl.h"
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_sdio_decl.h b/drivers/net/wireless/esp32/esp_sdio_decl.h
new file mode 100755
index 000000000..cc2a5cf6e
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_sdio_decl.h
@@ -0,0 +1,99 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _ESP_DECL_H_
+#define _ESP_DECL_H_
+
+#include "esp.h"
+
+/* Interrupt Status */
+#define ESP_SLAVE_BIT0_INT		BIT(0)
+#define ESP_SLAVE_BIT1_INT		BIT(1)
+#define ESP_SLAVE_BIT2_INT		BIT(2)
+#define ESP_SLAVE_BIT3_INT		BIT(3)
+#define ESP_SLAVE_BIT4_INT		BIT(4)
+#define ESP_SLAVE_BIT5_INT		BIT(5)
+#define ESP_SLAVE_BIT6_INT		BIT(6)
+#define ESP_SLAVE_BIT7_INT		BIT(7)
+#define ESP_SLAVE_RX_UNDERFLOW_INT	BIT(16)
+#define ESP_SLAVE_TX_OVERFLOW_INT	BIT(17)
+#define ESP_SLAVE_RX_NEW_PACKET_INT	BIT(23)
+
+
+#define ESP_SLAVE_CMD53_END_ADDR	0x1F800
+#define ESP_SLAVE_LEN_MASK		0xFFFFF
+#define ESP_BLOCK_SIZE			512
+#define ESP_RX_BYTE_MAX     		0x100000
+#define ESP_RX_BUFFER_SIZE		2048
+
+#define ESP_TX_BUFFER_MASK		0xFFF
+#define ESP_TX_BUFFER_MAX   		0x1000
+#define ESP_MAX_BUF_CNT			10
+
+#define ESP_SLAVE_SLCHOST_BASE      	0x3FF55000
+
+#define ESP_SLAVE_SCRATCH_REG_7		(ESP_SLAVE_SLCHOST_BASE + 0x8C)
+/* SLAVE registers */
+/* Interrupt Registers */
+#define ESP_SLAVE_INT_RAW_REG		(ESP_SLAVE_SLCHOST_BASE + 0x50)
+#define ESP_SLAVE_INT_ST_REG		(ESP_SLAVE_SLCHOST_BASE + 0x58)
+#define ESP_SLAVE_INT_CLR_REG		(ESP_SLAVE_SLCHOST_BASE + 0xD4)
+
+/* Data path registers*/
+#define ESP_SLAVE_PACKET_LEN_REG	(ESP_SLAVE_SLCHOST_BASE + 0x60)
+#define ESP_SLAVE_TOKEN_RDATA		(ESP_SLAVE_SLCHOST_BASE + 0x44)
+
+/* Scratch registers*/
+#define ESP_SLAVE_SCRATCH_REG_0		(ESP_SLAVE_SLCHOST_BASE + 0x6C)
+#define ESP_SLAVE_SCRATCH_REG_1		(ESP_SLAVE_SLCHOST_BASE + 0x70)
+#define ESP_SLAVE_SCRATCH_REG_2		(ESP_SLAVE_SLCHOST_BASE + 0x74)
+#define ESP_SLAVE_SCRATCH_REG_3		(ESP_SLAVE_SLCHOST_BASE + 0x78)
+#define ESP_SLAVE_SCRATCH_REG_4		(ESP_SLAVE_SLCHOST_BASE + 0x7C)
+#define ESP_SLAVE_SCRATCH_REG_6		(ESP_SLAVE_SLCHOST_BASE + 0x88)
+#define ESP_SLAVE_SCRATCH_REG_8		(ESP_SLAVE_SLCHOST_BASE + 0x9C)
+#define ESP_SLAVE_SCRATCH_REG_9		(ESP_SLAVE_SLCHOST_BASE + 0xA0)
+#define ESP_SLAVE_SCRATCH_REG_10	(ESP_SLAVE_SLCHOST_BASE + 0xA4)
+#define ESP_SLAVE_SCRATCH_REG_11	(ESP_SLAVE_SLCHOST_BASE + 0xA8)
+#define ESP_SLAVE_SCRATCH_REG_12	(ESP_SLAVE_SLCHOST_BASE + 0xAC)
+#define ESP_SLAVE_SCRATCH_REG_13	(ESP_SLAVE_SLCHOST_BASE + 0xB0)
+#define ESP_SLAVE_SCRATCH_REG_14	(ESP_SLAVE_SLCHOST_BASE + 0xB4)
+#define ESP_SLAVE_SCRATCH_REG_15	(ESP_SLAVE_SLCHOST_BASE + 0xB8)
+
+#define ESP_ADDRESS_MASK		0x3FF
+
+#define ESP_VENDOR_ID 			0x6666
+#define ESP_DEVICE_ID_1			0x2222
+#define ESP_DEVICE_ID_2			0x3333
+
+
+enum context_state {
+	ESP_CONTEXT_DISABLED = 0,
+	ESP_CONTEXT_INIT,
+	ESP_CONTEXT_READY
+};
+
+struct esp_sdio_context {
+	struct esp_adapter 	*adapter;
+	struct sdio_func	*func;
+	enum context_state	state;
+	u32 			rx_byte_count;
+	u32 			tx_buffer_count;
+};
+
+#endif
diff --git a/drivers/net/wireless/esp32/esp_serial.c b/drivers/net/wireless/esp32/esp_serial.c
new file mode 100755
index 000000000..c975f1a03
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_serial.c
@@ -0,0 +1,220 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#include "esp.h"
+#include "esp_rb.h"
+#include "esp_api.h"
+
+#define ESP_SERIAL_MAJOR	221
+#define ESP_SERIAL_MINOR_MAX	2
+#define ESP_RX_RB_SIZE	4096
+
+//#define ESP_SERIAL_TEST
+
+
+static struct esp_serial_devs {
+	struct cdev cdev;
+	int dev_index;
+	esp_rb_t rb;
+	void *priv;
+	struct mutex lock;
+} devs[ESP_SERIAL_MINOR_MAX];
+
+static int esp_serial_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)
+{
+	struct esp_serial_devs *dev;
+	size_t ret_size = 0;
+	dev = (struct esp_serial_devs *) file->private_data;
+	ret_size = esp_rb_read_by_user(&dev->rb, user_buffer, size, !(file->f_flags & O_NONBLOCK));
+	if (ret_size == 0) {
+		return -EAGAIN;
+	}
+
+	return ret_size;
+}
+
+static int esp_serial_write(struct file *file, const char __user *user_buffer, size_t size, loff_t * offset)
+{
+	struct esp_payload_header *hdr;
+	char *buf;
+	struct esp_serial_devs *dev;
+	int ret;
+	size_t total_len;
+
+	dev = (struct esp_serial_devs *) file->private_data;
+	total_len = size + sizeof(struct esp_payload_header);
+
+	buf = kmalloc(total_len, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_ERR "Error allocating buffer to send serial data\n");
+		return -ENOMEM;
+	}
+
+	hdr = (struct esp_payload_header *) buf;
+
+	memset (hdr, 0, sizeof(struct esp_payload_header));
+
+	hdr->if_type = ESP_SERIAL_IF;
+	hdr->if_num = dev->dev_index;
+	hdr->len = cpu_to_le16(size);
+	hdr->offset = cpu_to_le16(sizeof(struct esp_payload_header));
+
+	ret = copy_from_user(buf + hdr->offset, user_buffer, size);
+	if (ret != 0) {
+		kfree(buf);
+		printk(KERN_ERR "Error copying buffer to send serial data\n");
+		return -EFAULT;
+	}
+
+	/* print_hex_dump(KERN_INFO, "esp_serial_tx: ", DUMP_PREFIX_ADDRESS, 16, 1, buf, total_len, 1  ); */
+
+	ret = esp_send_packet(dev->priv, buf, total_len);
+	if (ret) {
+		printk (KERN_ERR "%s: Failed to transmit data\n", __func__);
+	}
+
+	kfree(buf);
+	return size;
+}
+
+static long esp_serial_ioctl (struct file *file, unsigned int cmd, unsigned long arg)
+{
+	printk(KERN_INFO "%s IOCTL %d\n", __func__, cmd);
+	return 0;
+}
+
+static int esp_serial_open(struct inode *inode, struct file *file)
+{
+	struct esp_serial_devs *devs;
+
+	devs = container_of(inode->i_cdev, struct esp_serial_devs, cdev);
+	file->private_data = devs;
+
+	return 0;
+}
+
+static unsigned int esp_serial_poll(struct file *file, poll_table *wait)
+{
+    struct esp_serial_devs *dev = (struct esp_serial_devs *)file->private_data;
+    unsigned int mask = 0;
+
+    mutex_lock(&dev->lock);
+    poll_wait(file, &dev->rb.wq,  wait);
+
+    if (dev->rb.rp != dev->rb.wp) {
+        mask |= (POLLIN | POLLRDNORM) ;   /* readable */
+    }
+    if (get_free_space(&dev->rb)) {
+        mask |= (POLLOUT | POLLWRNORM) ;  /* writable */
+    }
+
+    mutex_unlock(&dev->lock);
+    return mask;
+}
+
+const struct file_operations esp_serial_fops = {
+	.owner = THIS_MODULE,
+	.open = esp_serial_open,
+	.read = esp_serial_read,
+	.write = esp_serial_write,
+	.unlocked_ioctl = esp_serial_ioctl,
+	.poll = esp_serial_poll
+};
+
+int esp_serial_data_received(int dev_index, const char *data, size_t len)
+{
+	int ret;
+	size_t ret_len = 0;
+
+	while (ret_len != len) {
+		ret = esp_rb_write_by_kernel(&devs[dev_index].rb, data, len);
+		ret_len += ret;
+		if (ret == 0) {
+			break;
+		}
+	}
+	if (ret_len != len) {
+		printk(KERN_ERR "RB full, no space to receive. Dropping packet");
+	}
+
+	return ret_len;
+}
+
+#ifdef ESP_SERIAL_TEST
+static int thread_fn(void *unused)
+{
+	int i = 100;
+
+	while(i--) {
+		esp_rb_write_by_kernel(&devs[0].rb, "alphabetagamma", 14);
+		ssleep(1);
+	}
+	printk(KERN_INFO "Thread stopping\n");
+	do_exit(0);
+	return 0;
+}
+#endif
+
+int esp_serial_init(void *priv)
+{
+	int err;
+	int i;
+
+	err = register_chrdev_region(MKDEV(ESP_SERIAL_MAJOR, 0), ESP_SERIAL_MINOR_MAX, "esp_serial_driver");
+	if (err) {
+		printk(KERN_ERR "Error registering chrdev region %d\n", err);
+		return -1;
+	}
+
+	for (i = 0; i < ESP_SERIAL_MINOR_MAX; i++) {
+		cdev_init(&devs[i].cdev, &esp_serial_fops);
+		devs[i].dev_index = i;
+		cdev_add(&devs[i].cdev, MKDEV(ESP_SERIAL_MAJOR, i), 1);
+		esp_rb_init(&devs[i].rb, ESP_RX_RB_SIZE);
+		devs[i].priv = priv;
+		mutex_init(&devs[i].lock);
+	}
+
+#ifdef ESP_SERIAL_TEST
+	kthread_run(thread_fn, NULL, "esptest-thread");
+#endif
+	return 0;
+}
+
+void esp_serial_cleanup(void)
+{
+	int i;
+	for (i = 0; i < ESP_SERIAL_MINOR_MAX; i++) {
+		cdev_del(&devs[i].cdev);
+		esp_rb_cleanup(&devs[i].rb);
+		mutex_destroy(&devs[i].lock);
+	}
+	unregister_chrdev_region(MKDEV(ESP_SERIAL_MAJOR, 0), ESP_SERIAL_MINOR_MAX);
+	return;
+}
diff --git a/drivers/net/wireless/esp32/esp_serial.h b/drivers/net/wireless/esp32/esp_serial.h
new file mode 100755
index 000000000..b51c51ef0
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_serial.h
@@ -0,0 +1,27 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _ESP_SERIAL_H_
+#define _ESP_SERIAL_H_
+
+int esp_serial_init(void * priv);
+void esp_serial_cleanup(void);
+
+int esp_serial_data_received(int dev_index, const char *data, size_t len);
+#endif
diff --git a/drivers/net/wireless/esp32/esp_spi.c b/drivers/net/wireless/esp32/esp_spi.c
new file mode 100755
index 000000000..520eb2f45
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_spi.c
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include "esp_spi.h"
+#include "esp_if.h"
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+#include "esp_serial.h"
+#endif
+
+#define SPI_INITIAL_CLK_MHZ     10
+#define NUMBER_1M               1000000
+
+/* ESP in sdkconfig has CONFIG_IDF_FIRMWARE_CHIP_ID entry.
+ * supported values of CONFIG_IDF_FIRMWARE_CHIP_ID are - */
+#define ESP_PRIV_FIRMWARE_CHIP_UNRECOGNIZED (0xff)
+#define ESP_PRIV_FIRMWARE_CHIP_ESP32        (0x0)
+#define ESP_PRIV_FIRMWARE_CHIP_ESP32S2      (0x2)
+
+static struct sk_buff * read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, u8 *buf, u32 size);
+static void spi_exit(void);
+static void adjust_spi_clock(u8 spi_clk_mhz);
+
+volatile u8 data_path = 0;
+static struct esp_spi_context spi_context;
+static char hardware_type = 0;
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static DEFINE_MUTEX(spi_lock);
+
+static void open_data_path(void)
+{
+	msleep(200);
+	data_path = OPEN_DATAPATH;
+}
+
+static void close_data_path(void)
+{
+	data_path = CLOSE_DATAPATH;
+	msleep(200);
+}
+
+static irqreturn_t spi_data_ready_interrupt_handler(int irq, void * dev)
+{
+	/* ESP peripheral has queued buffer for transmission */
+ 	if (spi_context.spi_workqueue)
+ 		queue_work(spi_context.spi_workqueue, &spi_context.spi_work);
+
+ 	return IRQ_HANDLED;
+ }
+
+static irqreturn_t spi_interrupt_handler(int irq, void * dev)
+{
+	/* ESP peripheral is ready for next SPI transaction */
+	if (spi_context.spi_workqueue)
+		queue_work(spi_context.spi_workqueue, &spi_context.spi_work);
+
+	return IRQ_HANDLED;
+}
+
+static struct sk_buff * read_packet(struct esp_adapter *adapter)
+{
+	struct esp_spi_context *context;
+	struct sk_buff *skb = NULL;
+
+	if (!data_path) {
+		return NULL;
+	}
+
+	if (!adapter || !adapter->if_context) {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return NULL;
+	}
+
+	context = adapter->if_context;
+
+	if (context->esp_spi_dev) {
+		skb = skb_dequeue(&(context->rx_q));
+	} else {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return NULL;
+	}
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, u8 *buf, u32 size)
+{
+	struct esp_spi_context *context;
+	struct sk_buff *skb;
+	u8 *tx_buf = NULL;
+
+	if (!adapter || !adapter->if_context || !buf || !size || (size > SPI_BUF_SIZE)) {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!data_path) {
+		return -EPERM;
+	}
+
+	/* Adjust length to make it multiple of 4 bytes  */
+	size += 4 - (size & 3);
+
+	context = adapter->if_context;
+
+	skb = esp_alloc_skb(size);
+
+	if (!skb)
+		return -ENOMEM;
+
+	tx_buf = skb_put(skb, size);
+
+	if (!tx_buf) {
+		dev_kfree_skb(skb);
+		return -ENOMEM;
+	}
+
+	/* TODO: This memecpy can be avoided if this function receives SKB as an argument */
+	memcpy(tx_buf, buf, size);
+
+	/* Enqueue SKB in tx_q */
+	skb_queue_tail(&spi_context.tx_q, skb);
+
+	if (spi_context.spi_workqueue)
+		queue_work(spi_context.spi_workqueue, &spi_context.spi_work);
+
+	return 0;
+}
+
+static void process_capabilities(u8 cap)
+{
+	printk (KERN_INFO "ESP peripheral capabilities: 0x%x\n", cap);
+
+	/* Reset BT */
+	esp_deinit_bt(spi_context.adapter);
+
+	if ((cap & ESP_BT_SPI_SUPPORT) || (cap & ESP_BT_SDIO_SUPPORT)) {
+		msleep(200);
+		esp_init_bt(spi_context.adapter);
+	}
+}
+
+static void process_init_event(u8 *evt_buf, u8 len)
+{
+	u8 len_left = len, tag_len;
+	u8 *pos;
+
+	if (!evt_buf)
+		return;
+
+	pos = evt_buf;
+
+	while (len_left) {
+		tag_len = *(pos + 1);
+		printk(KERN_INFO "EVENT: %d\n", *pos);
+		if (*pos == ESP_PRIV_CAPABILITY) {
+			process_capabilities(*(pos + 2));
+		} else if (*pos == ESP_PRIV_SPI_CLK_MHZ){
+			adjust_spi_clock(*(pos + 2));
+		} else if (*pos == ESP_PRIV_FIRMWARE_CHIP_ID){
+			hardware_type = *(pos+2);
+		} else {
+			printk (KERN_WARNING "Unsupported tag in event");
+		}
+		pos += (tag_len+2);
+		len_left -= (tag_len+2);
+	}
+	if ((hardware_type != ESP_PRIV_FIRMWARE_CHIP_ESP32) &&
+	    (hardware_type != ESP_PRIV_FIRMWARE_CHIP_ESP32S2)) {
+		printk(KERN_INFO "ESP board type is not mentioned, ignoring\n");
+		hardware_type = ESP_PRIV_FIRMWARE_CHIP_UNRECOGNIZED;
+	}
+}
+
+static void process_event(u8 *evt_buf, u16 len)
+{
+	struct esp_priv_event *event;
+
+	if (!evt_buf || !len)
+		return;
+
+	event = (struct esp_priv_event *) evt_buf;
+
+	if (event->event_type == ESP_PRIV_EVENT_INIT) {
+		printk (KERN_INFO "Received INIT event from ESP32 peripheral");
+		process_init_event(event->event_data, event->event_len);
+	} else {
+		printk (KERN_WARNING "Drop unknown event");
+	}
+}
+
+static void process_priv_communication(struct sk_buff *skb)
+{
+	struct esp_payload_header *header;
+	u8 *payload;
+	u16 len;
+
+	if (!skb || !skb->data)
+		return;
+
+	header = (struct esp_payload_header *) skb->data;
+
+	payload = skb->data + le16_to_cpu(header->offset);
+	len = le16_to_cpu(header->len);
+
+	if (header->priv_pkt_type == ESP_PACKET_TYPE_EVENT) {
+		process_event(payload, len);
+	}
+
+	dev_kfree_skb(skb);
+}
+
+static int process_rx_buf(struct sk_buff *skb)
+{
+	struct esp_payload_header *header;
+	u16 len = 0;
+	u16 offset = 0;
+
+	if (!skb)
+		return -EINVAL;
+
+	header = (struct esp_payload_header *) skb->data;
+
+	if (header->if_type >= ESP_MAX_IF) {
+		return -EINVAL;
+	}
+
+	offset = le16_to_cpu(header->offset);
+
+	/* Validate received SKB. Check len and offset fields */
+	if (offset != sizeof(struct esp_payload_header)) {
+		return -EINVAL;
+	}
+
+	len = le16_to_cpu(header->len);
+	if (!len) {
+		return -EINVAL;
+	}
+
+	len += sizeof(struct esp_payload_header);
+
+	if (len > SPI_BUF_SIZE) {
+		return -EINVAL;
+	}
+
+	/* Trim SKB to actual size */
+	skb_trim(skb, len);
+
+	if (header->if_type == ESP_PRIV_IF) {
+		process_priv_communication(skb);
+		return 0;
+	}
+
+	if (!data_path)
+		return -EPERM;
+
+	/* enqueue skb for read_packet to pick it */
+	skb_queue_tail(&spi_context.rx_q, skb);
+
+	/* indicate reception of new packet */
+	esp_process_new_packet_intr(spi_context.adapter);
+
+	return 0;
+}
+
+static void esp_spi_work(struct work_struct *work)
+{
+	struct spi_transfer trans;
+	struct sk_buff *tx_skb = NULL, *rx_skb = NULL;
+	u8 *rx_buf;
+	int ret = 0;
+	int trans_ready, rx_pending;
+
+	mutex_lock(&spi_lock);
+
+	trans_ready = gpio_get_value(HANDSHAKE_PIN);
+	rx_pending = gpio_get_value(SPI_DATA_READY_PIN);
+
+
+	if (trans_ready) {
+		if (data_path)
+			tx_skb = skb_dequeue(&spi_context.tx_q);
+
+		if (rx_pending || tx_skb) {
+			memset(&trans, 0, sizeof(trans));
+
+			/* Setup and execute SPI transaction
+			 * 	Tx_buf: Check if tx_q has valid buffer for transmission,
+			 * 		else keep it blank
+			 *
+			 * 	Rx_buf: Allocate memory for incoming data. This will be freed
+			 *		immediately if received buffer is invalid.
+			 *		If it is a valid buffer, upper layer will free it.
+			 * */
+
+			/* Configure TX buffer if available */
+
+			if (tx_skb) {
+				trans.tx_buf = tx_skb->data;
+			} else {
+				tx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+				trans.tx_buf = skb_put(tx_skb, SPI_BUF_SIZE);
+				memset((void*)trans.tx_buf, 0, SPI_BUF_SIZE);
+			}
+
+			/* Configure RX buffer */
+			rx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+			rx_buf = skb_put(rx_skb, SPI_BUF_SIZE);
+
+			memset(rx_buf, 0, SPI_BUF_SIZE);
+
+			trans.rx_buf = rx_buf;
+			trans.len = SPI_BUF_SIZE;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+			if (hardware_type == ESP_PRIV_FIRMWARE_CHIP_ESP32) {
+				trans.cs_change = 1;
+			}
+#endif
+
+			ret = spi_sync_transfer(spi_context.esp_spi_dev, &trans, 1);
+			if (ret) {
+				printk(KERN_ERR "SPI Transaction failed: %d", ret);
+				dev_kfree_skb(rx_skb);
+				dev_kfree_skb(tx_skb);
+			} else {
+
+				/* Free rx_skb if received data is not valid */
+				if (process_rx_buf(rx_skb)) {
+					dev_kfree_skb(rx_skb);
+				}
+
+				if (tx_skb)
+					dev_kfree_skb(tx_skb);
+			}
+		}
+	}
+
+	mutex_unlock(&spi_lock);
+}
+
+static int spi_dev_init(int spi_clk_mhz)
+{
+	int status = 0;
+	struct spi_board_info esp_board = {{0}};
+	struct spi_master *master = NULL;
+
+	strlcpy(esp_board.modalias, "esp_spi", sizeof(esp_board.modalias));
+	esp_board.mode = SPI_MODE_2;
+	esp_board.max_speed_hz = spi_clk_mhz * NUMBER_1M;
+	esp_board.bus_num = 0;
+	esp_board.chip_select = 0;
+
+	master = spi_busnum_to_master(esp_board.bus_num);
+	if (!master) {
+		printk(KERN_ERR "Failed to obtain SPI master handle\n");
+		return -ENODEV;
+	}
+
+	spi_context.esp_spi_dev = spi_new_device(master, &esp_board);
+
+	if (!spi_context.esp_spi_dev) {
+		printk(KERN_ERR "Failed to add new SPI device\n");
+		return -ENODEV;
+	}
+
+	status = spi_setup(spi_context.esp_spi_dev);
+
+	if (status) {
+		printk (KERN_ERR "Failed to setup new SPI device");
+		return status;
+	}
+
+	printk (KERN_INFO "ESP32 peripheral is registered to SPI bus [%d]"
+			",chip select [%d]\n", esp_board.bus_num,
+			esp_board.chip_select);
+
+	status = gpio_request(HANDSHAKE_PIN, "SPI_HANDSHAKE_PIN");
+
+	if (status) {
+		printk (KERN_ERR "Failed to obtain GPIO for Handshake pin\n");
+		return status;
+	}
+
+	status = gpio_direction_input(HANDSHAKE_PIN);
+
+	if (status) {
+		printk (KERN_ERR "Failed to set GPIO direction of Handshake pin\n");
+		return status;
+	}
+
+	status = request_irq(SPI_IRQ, spi_interrupt_handler,
+			IRQF_SHARED | IRQF_TRIGGER_RISING,
+			"ESP_SPI", spi_context.esp_spi_dev);
+	if (status) {
+		printk (KERN_ERR "Failed to request IRQ for Handshake pin\n");
+		return status;
+	}
+
+	status = gpio_request(SPI_DATA_READY_PIN, "SPI_DATA_READY_PIN");
+	if (status) {
+		printk (KERN_ERR "Failed to obtain GPIO for Data ready pin\n");
+		return status;
+	}
+
+	status = gpio_direction_input(SPI_DATA_READY_PIN);
+	if (status) {
+		printk (KERN_ERR "Failed to set GPIO direction of Data ready pin\n");
+		return status;
+	}
+
+	status = request_irq(SPI_DATA_READY_IRQ, spi_data_ready_interrupt_handler,
+			IRQF_SHARED | IRQF_TRIGGER_RISING,
+			"ESP_SPI_DATA_READY", spi_context.esp_spi_dev);
+	if (status) {
+		printk (KERN_ERR "Failed to request IRQ for Data ready pin\n");
+		return status;
+	}
+
+	open_data_path();
+
+	return 0;
+}
+
+static int spi_reinit_spidev(int spi_clk_mhz)
+{
+	disable_irq(SPI_IRQ);
+	disable_irq(SPI_DATA_READY_IRQ);
+	close_data_path();
+	free_irq(SPI_IRQ, spi_context.esp_spi_dev);
+	free_irq(SPI_DATA_READY_IRQ, spi_context.esp_spi_dev);
+	gpio_free(HANDSHAKE_PIN);
+	gpio_free(SPI_DATA_READY_PIN);
+
+	if (spi_context.esp_spi_dev)
+		spi_unregister_device(spi_context.esp_spi_dev);
+
+	return spi_dev_init(spi_clk_mhz);
+}
+
+static int spi_init(void)
+{
+	int status = 0;
+
+	spi_context.spi_workqueue = create_workqueue("ESP_SPI_WORK_QUEUE");
+
+	if (!spi_context.spi_workqueue) {
+		printk(KERN_ERR "spi workqueue failed to create\n");
+		spi_exit();
+		return -EFAULT;
+	}
+
+	INIT_WORK(&spi_context.spi_work, esp_spi_work);
+
+	skb_queue_head_init(&spi_context.tx_q);
+	skb_queue_head_init(&spi_context.rx_q);
+
+	status = spi_dev_init(SPI_INITIAL_CLK_MHZ);
+	if (status) {
+		spi_exit();
+		printk (KERN_ERR "Failed Init SPI device\n");
+		return status;
+	}
+
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+	status = esp_serial_init((void *) spi_context.adapter);
+	if (status != 0) {
+		spi_exit();
+		printk(KERN_ERR "Error initialising serial interface\n");
+		return status;
+	}
+#endif
+
+	status = esp_add_card(spi_context.adapter);
+	if (status) {
+		spi_exit();
+		printk (KERN_ERR "Failed to add card\n");
+		return status;
+	}
+
+	msleep(200);
+
+	return status;
+}
+
+static void spi_exit(void)
+{
+	disable_irq(SPI_IRQ);
+	disable_irq(SPI_DATA_READY_IRQ);
+	close_data_path();
+	msleep(200);
+
+	skb_queue_purge(&spi_context.tx_q);
+	skb_queue_purge(&spi_context.rx_q);
+
+	if (spi_context.spi_workqueue) {
+		flush_scheduled_work();
+		destroy_workqueue(spi_context.spi_workqueue);
+		spi_context.spi_workqueue = NULL;
+	}
+
+	esp_serial_cleanup();
+	esp_remove_card(spi_context.adapter);
+
+	if (spi_context.adapter->hcidev)
+		esp_deinit_bt(spi_context.adapter);
+
+	free_irq(SPI_IRQ, spi_context.esp_spi_dev);
+	free_irq(SPI_DATA_READY_IRQ, spi_context.esp_spi_dev);
+
+	gpio_free(HANDSHAKE_PIN);
+	gpio_free(SPI_DATA_READY_PIN);
+
+	if (spi_context.esp_spi_dev)
+		spi_unregister_device(spi_context.esp_spi_dev);
+
+	memset(&spi_context, 0, sizeof(spi_context));
+}
+
+static void adjust_spi_clock(u8 spi_clk_mhz)
+{
+	if ((spi_clk_mhz) && (spi_clk_mhz != SPI_INITIAL_CLK_MHZ)) {
+		printk(KERN_INFO "ESP Reconfigure SPI CLK to %u MHz\n",spi_clk_mhz);
+
+		if (spi_reinit_spidev(spi_clk_mhz)) {
+			printk(KERN_ERR "Failed to reinit SPI device\n");
+			spi_exit();
+			return;
+		}
+	}
+}
+
+int esp_init_interface_layer(struct esp_adapter *adapter)
+{
+	if (!adapter)
+		return -EINVAL;
+
+	memset(&spi_context, 0, sizeof(spi_context));
+
+	adapter->if_context = &spi_context;
+	adapter->if_ops = &if_ops;
+	adapter->if_type = ESP_IF_TYPE_SPI;
+	spi_context.adapter = adapter;
+
+	return spi_init();
+}
+
+void esp_deinit_interface_layer(void)
+{
+	spi_exit();
+}
diff --git a/drivers/net/wireless/esp32/esp_spi.h b/drivers/net/wireless/esp32/esp_spi.h
new file mode 100755
index 000000000..2c199af42
--- /dev/null
+++ b/drivers/net/wireless/esp32/esp_spi.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#ifndef _ESP_SPI_H_
+#define _ESP_SPI_H_
+
+#include "esp.h"
+
+#define HANDSHAKE_PIN           17
+#define SPI_IRQ                 gpio_to_irq(HANDSHAKE_PIN)
+#define SPI_DATA_READY_PIN      27
+#define SPI_DATA_READY_IRQ      gpio_to_irq(SPI_DATA_READY_PIN)
+#define SPI_BUF_SIZE            1600
+
+struct esp_spi_context {
+	struct esp_adapter          *adapter;
+	struct spi_device           *esp_spi_dev;
+	struct sk_buff_head         tx_q;
+	struct sk_buff_head         rx_q;
+	struct workqueue_struct     *spi_workqueue;
+	struct work_struct          spi_work;
+};
+
+enum {
+	CLOSE_DATAPATH,
+	OPEN_DATAPATH,
+};
+
+
+#endif
diff --git a/drivers/net/wireless/esp32/main.c b/drivers/net/wireless/esp32/main.c
new file mode 100755
index 000000000..9f378df0e
--- /dev/null
+++ b/drivers/net/wireless/esp32/main.c
@@ -0,0 +1,690 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2020 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/timekeeping.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
+#include <linux/gpio.h>
+
+#include "esp.h"
+#include "esp_if.h"
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+#include "esp_serial.h"
+#endif
+#include "esp_bt_api.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amey Inamdar <amey.inamdar@espressif.com>");
+MODULE_AUTHOR("Mangesh Malusare <mangesh.malusare@espressif.com>");
+MODULE_AUTHOR("Yogesh Mantri <yogesh.mantri@espressif.com>");
+MODULE_DESCRIPTION("Host driver for ESP-Hosted solution");
+MODULE_VERSION("0.01");
+
+struct esp_adapter adapter;
+volatile u8 stop_data = 0;
+
+#define ACTION_DROP 1
+/* Unless specified as part of argument, resetpin,
+ * do not reset ESP32.
+ */
+#define HOST_GPIO_PIN_INVALID -1
+static int resetpin = HOST_GPIO_PIN_INVALID;
+
+module_param(resetpin, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(resetpin, "Host's GPIO pin number which is connected to ESP32's EN to reset ESP32 device");
+
+static int esp_open(struct net_device *ndev);
+static int esp_stop(struct net_device *ndev);
+static int esp_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev);
+static int esp_set_mac_address(struct net_device *ndev, void *addr);
+static void esp_tx_timeout(struct net_device *ndev);
+static struct net_device_stats* esp_get_stats(struct net_device *ndev);
+static void esp_set_rx_mode(struct net_device *ndev);
+int esp_send_packet(struct esp_adapter *adapter, u8 *buf, u32 size);
+
+static const struct net_device_ops esp_netdev_ops = {
+	.ndo_open = esp_open,
+	.ndo_stop = esp_stop,
+	.ndo_start_xmit = esp_hard_start_xmit,
+	.ndo_set_mac_address = esp_set_mac_address,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_tx_timeout = esp_tx_timeout,
+	.ndo_get_stats = esp_get_stats,
+	.ndo_set_rx_mode = esp_set_rx_mode,
+};
+
+#if 0
+u64 start_time, end_time;
+#endif
+
+struct esp_adapter * esp_get_adapter(void)
+{
+	return &adapter;
+}
+
+static int esp_open(struct net_device *ndev)
+{
+	netif_start_queue(ndev);
+	return 0;
+}
+
+static int esp_stop(struct net_device *ndev)
+{
+	netif_stop_queue(ndev);
+	return 0;
+}
+
+static struct net_device_stats* esp_get_stats(struct net_device *ndev)
+{
+	struct esp_private *priv = netdev_priv(ndev);
+	return &priv->stats;
+}
+
+static int esp_set_mac_address(struct net_device *ndev, void *data)
+{
+	struct esp_private *priv = netdev_priv(ndev);
+	struct sockaddr *mac_addr = data;
+
+	if (!priv)
+		return -EINVAL;
+
+	ether_addr_copy(priv->mac_address, mac_addr->sa_data);
+	ether_addr_copy(ndev->dev_addr, mac_addr->sa_data);
+	return 0;
+}
+
+static void esp_tx_timeout(struct net_device *ndev)
+{
+}
+
+static void esp_set_rx_mode(struct net_device *ndev)
+{
+}
+
+static int esp_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sk_buff *new_skb;
+	struct esp_private *priv = netdev_priv(ndev);
+	struct esp_skb_cb *cb;
+
+	if (!priv) {
+		dev_kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	if (!skb->len || (skb->len > ETH_FRAME_LEN)) {
+		printk (KERN_ERR "%s: Bad len %d\n", __func__, skb->len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	if (skb_headroom(skb) < ESP_PAYLOAD_HEADER) {
+		/* Insufficient space. Realloc skb. */
+		new_skb = skb_realloc_headroom(skb, ESP_PAYLOAD_HEADER);
+
+		if (unlikely(!new_skb)) {
+			printk (KERN_ERR "%s: Failed to allocate SKB\n", __func__);
+			priv->stats.tx_dropped++;
+			dev_kfree_skb(skb);
+			return -ENOMEM;
+		}
+
+		/* Free old SKB */
+		dev_kfree_skb(skb);
+
+		skb = new_skb;
+	}
+
+	cb = (struct esp_skb_cb *) skb->cb;
+	cb->priv = priv;
+
+/*	print_hex_dump_bytes("Tx:", DUMP_PREFIX_NONE, skb->data, 8);*/
+
+	skb_queue_tail(&adapter.tx_q, skb);
+	atomic_inc(&adapter.tx_pending);
+	queue_work(adapter.tx_workqueue, &adapter.tx_work);
+
+	return 0;
+}
+
+u8 esp_is_bt_supported_over_sdio(u32 cap)
+{
+	return (cap & ESP_BT_SDIO_SUPPORT);
+}
+
+static struct esp_private * get_priv_from_payload_header(struct esp_payload_header *header)
+{
+	struct esp_private *priv;
+	u8 i;
+
+	if (!header)
+		return NULL;
+
+	for (i = 0; i < ESP_MAX_INTERFACE; i++) {
+		priv = adapter.priv[i];
+
+		if (!priv)
+			continue;
+
+		if (priv->if_type == header->if_type &&
+				priv->if_num == header->if_num) {
+			return priv;
+		}
+	}
+
+	return NULL;
+}
+
+void esp_process_new_packet_intr(struct esp_adapter *adapter)
+{
+	if(adapter)
+		queue_work(adapter->if_rx_workqueue, &adapter->if_rx_work);
+}
+
+static void process_tx_packet (void)
+{
+	struct sk_buff *skb;
+	struct esp_private *priv;
+	struct esp_skb_cb *cb;
+	struct esp_payload_header *payload_header;
+	struct sk_buff *new_skb;
+	int ret = 0;
+	u8 pad_len = 0;
+	u16 len = 0;
+	static u32 c = 0;
+
+	while ((skb = skb_dequeue(&adapter.tx_q))) {
+		c++;
+		/* Get the priv */
+		cb = (struct esp_skb_cb *) skb->cb;
+		priv = cb->priv;
+
+		if (!priv) {
+			dev_kfree_skb_any(skb);
+			atomic_dec(&adapter.tx_pending);
+			continue;
+		}
+
+		len = skb->len;
+
+		/* Create space for payload header */
+		pad_len = sizeof(struct esp_payload_header);
+
+		if (skb_headroom(skb) < pad_len) {
+			/* insufficent headroom to add payload header */
+			new_skb = skb_realloc_headroom(skb, pad_len);
+
+			if(!new_skb) {
+				printk(KERN_ERR "%s: Failed to allocate SKB", __func__);
+				dev_kfree_skb(skb);
+				atomic_dec(&adapter.tx_pending);
+				continue;
+			}
+
+			dev_kfree_skb(skb);
+
+			skb = new_skb;
+		}
+
+		skb_push(skb, pad_len);
+
+		/* Set payload header */
+		payload_header = (struct esp_payload_header *) skb->data;
+		memset(payload_header, 0, pad_len);
+
+		payload_header->if_type = priv->if_type;
+		payload_header->if_num = priv->if_num;
+		payload_header->len = cpu_to_le16(skb->len - pad_len);
+		payload_header->offset = cpu_to_le16(pad_len);
+		payload_header->reserved1 = c % 255;
+
+/*		printk (KERN_ERR "H -> S: %d %d %d %d", len, payload_header->offset,*/
+/*				payload_header->len, payload_header->reserved1);*/
+
+		if (!stop_data) {
+			ret = esp_send_packet(priv->adapter, skb->data, skb->len);
+
+			if (ret) {
+				priv->stats.tx_errors++;
+			} else {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += skb->len;
+			}
+		} else {
+			priv->stats.tx_dropped++;
+		}
+
+		dev_kfree_skb_any(skb);
+		atomic_dec(&adapter.tx_pending);
+	}
+}
+
+static void process_rx_packet(struct sk_buff *skb)
+{
+	struct esp_private *priv;
+	struct esp_payload_header *payload_header;
+	u16 len, offset;
+	struct hci_dev *hdev = adapter.hcidev;
+	u8 *type;
+
+	if (!skb)
+		return;
+
+	/* get the paload header */
+	payload_header = (struct esp_payload_header *) skb->data;
+
+	len = le16_to_cpu(payload_header->len);
+	offset = le16_to_cpu(payload_header->offset);
+
+	if (payload_header->if_type == ESP_SERIAL_IF) {
+#ifdef CONFIG_SUPPORT_ESP_SERIAL
+		/* print_hex_dump(KERN_INFO, "esp_serial_rx: ", DUMP_PREFIX_ADDRESS, 16, 1, skb->data + offset, len, 1  ); */
+		esp_serial_data_received(payload_header->if_num, skb->data + offset, len);
+#else
+		printk(KERN_ERR "Dropping unsupported serial frame\n");
+#endif
+		dev_kfree_skb_any(skb);
+	} else if (payload_header->if_type == ESP_STA_IF || payload_header->if_type == ESP_AP_IF) {
+		/* chop off the header from skb */
+		skb_pull(skb, offset);
+
+		/* retrieve priv based on payload header contents */
+		priv = get_priv_from_payload_header(payload_header);
+
+		if (!priv) {
+			printk (KERN_ERR "%s: empty priv\n", __func__);
+			dev_kfree_skb_any(skb);
+/*			atomic_dec(&adapter.rx_pending);*/
+			return;
+		}
+
+		skb->dev = priv->ndev;
+		skb->protocol = eth_type_trans(skb, priv->ndev);
+		skb->ip_summed = CHECKSUM_NONE;
+		/*		print_hex_dump_bytes("Rx:", DUMP_PREFIX_NONE, skb->data, 8);*/
+
+		/* Forward skb to kernel */
+		netif_rx(skb);
+
+		priv->stats.rx_bytes += skb->len;
+		priv->stats.rx_packets++;
+	} else if (payload_header->if_type == ESP_HCI_IF) {
+		if (hdev) {
+			/* chop off the header from skb */
+			skb_pull(skb, offset);
+
+			type = skb->data;
+			hci_skb_pkt_type(skb) = *type;
+			skb_pull(skb, 1);
+
+			if (hci_recv_frame(hdev, skb)) {
+				hdev->stat.err_rx++;
+			} else {
+				esp_hci_update_rx_counter(hdev, *type, skb->len);
+			}
+		}
+	}
+}
+
+struct sk_buff * esp_alloc_skb(u32 len)
+{
+	struct sk_buff *skb;
+
+	skb = netdev_alloc_skb(NULL, len);
+	return skb;
+}
+
+
+static int esp_get_packets(struct esp_adapter *adapter)
+{
+	struct sk_buff *skb;
+
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->read)
+		return -EINVAL;
+
+	skb = adapter->if_ops->read(adapter);
+
+	if (!skb)
+		return -EFAULT;
+
+	process_rx_packet(skb);
+
+	return 0;
+}
+
+int esp_send_packet(struct esp_adapter *adapter, u8 *buf, u32 size)
+{
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->write)
+		return -EINVAL;
+
+	return adapter->if_ops->write(adapter, buf, size);
+}
+
+static int insert_priv_to_adapter(struct esp_private *priv)
+{
+	int i = 0;
+
+	for (i = 0; i < ESP_MAX_INTERFACE; i++) {
+		/* Check if priv can be added */
+		if (adapter.priv[i] == NULL) {
+			adapter.priv[i] = priv;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int esp_init_priv(struct esp_private *priv, struct net_device *dev,
+		u8 if_type, u8 if_num)
+{
+	int ret = 0;
+
+	if (!priv || !dev)
+		return -EINVAL;
+
+	ret = insert_priv_to_adapter(priv);
+	if (ret)
+		return ret;
+
+	priv->ndev = dev;
+	priv->if_type = if_type;
+	priv->if_num = if_num;
+	priv->link_state = ESP_LINK_DOWN;
+	priv->adapter = &adapter;
+	memset(&priv->stats, 0, sizeof(priv->stats));
+
+	return 0;
+}
+
+static int esp_init_net_dev(struct net_device *ndev, struct esp_private *priv)
+{
+	int ret = 0;
+	/* Set netdev */
+/*	SET_NETDEV_DEV(ndev, &adapter->context.func->dev);*/
+
+	/* set net dev ops */
+	ndev->netdev_ops = &esp_netdev_ops;
+
+	ether_addr_copy(ndev->dev_addr, priv->mac_address);
+	/* set ethtool ops */
+
+	/* update features supported */
+
+	/* min mtu */
+
+	/* register netdev */
+	ret = register_netdev(ndev);
+
+/*	netif_start_queue(ndev);*/
+	/* ndev->needs_free_netdev = true; */
+
+	/* set watchdog timeout */
+
+	return ret;
+}
+
+static int esp_add_interface(struct esp_adapter *adapter, u8 if_type, u8 if_num, char *name)
+{
+	struct net_device *ndev = NULL;
+	struct esp_private *priv = NULL;
+	int ret = 0;
+
+	ndev = alloc_netdev_mqs(sizeof(struct esp_private), name,
+			NET_NAME_ENUM, ether_setup, 1, 1);
+
+	if (!ndev) {
+		printk(KERN_ERR "%s: alloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	priv = netdev_priv(ndev);
+
+	/* Init priv */
+	ret = esp_init_priv(priv, ndev, if_type, if_num);
+	if (ret) {
+		printk(KERN_ERR "%s: Init priv failed\n", __func__);
+		goto error_exit;
+	}
+
+	ret = esp_init_net_dev(ndev, priv);
+	if (ret) {
+		printk(KERN_ERR "%s: Init netdev failed\n", __func__);
+		goto error_exit;
+	}
+
+	return ret;
+
+error_exit:
+	free_netdev(ndev);
+	return ret;
+}
+
+static void flush_ring_buffers(struct esp_adapter *adapter)
+{
+	struct sk_buff *skb;
+
+	printk (KERN_INFO "%s: Flush Pending SKBs: %d %d\n", __func__,
+			atomic_read(&adapter->tx_pending),
+			atomic_read(&adapter->rx_pending));
+
+	while ((skb = skb_dequeue(&adapter->tx_q))) {
+		dev_kfree_skb_any(skb);
+		atomic_dec(&adapter->tx_pending);
+	}
+
+	while ((skb = skb_dequeue(&adapter->rx_q))) {
+		dev_kfree_skb_any(skb);
+		atomic_dec(&adapter->rx_pending);
+	}
+}
+
+static void esp_remove_network_interfaces(struct esp_adapter *adapter)
+{
+	if (adapter->priv[0]->ndev) {
+		netif_stop_queue(adapter->priv[0]->ndev);
+		unregister_netdev(adapter->priv[0]->ndev);
+		free_netdev(adapter->priv[0]->ndev);
+	}
+
+	if (adapter->priv[1]->ndev) {
+		netif_stop_queue(adapter->priv[1]->ndev);
+		unregister_netdev(adapter->priv[1]->ndev);
+		free_netdev(adapter->priv[1]->ndev);
+	}
+}
+
+int esp_add_card(struct esp_adapter *adapter)
+{
+	int ret = 0;
+
+	if (!adapter) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return -EINVAL;
+	}
+
+	stop_data = 0;
+
+	/* Add interface STA and AP */
+	ret = esp_add_interface(adapter, ESP_STA_IF, 0, "ethsta%d");
+	if (ret) {
+		printk(KERN_ERR "%s: Failed to add STA\n", __func__);
+		return ret;
+	}
+
+	ret = esp_add_interface(adapter, ESP_AP_IF, 0, "ethap%d");
+	if (ret) {
+		printk(KERN_ERR "%s: Failed to add AP\n", __func__);
+		esp_remove_network_interfaces(adapter);
+	}
+
+	return ret;
+}
+
+int esp_remove_card(struct esp_adapter *adapter)
+{
+	stop_data = 1;
+
+	if (!adapter)
+		return 0;
+
+	/* Flush workqueues */
+	if (adapter->if_rx_workqueue)
+		flush_workqueue(adapter->if_rx_workqueue);
+
+	if (adapter->tx_workqueue)
+		flush_workqueue(adapter->tx_workqueue);
+
+	esp_remove_network_interfaces(adapter);
+
+	flush_ring_buffers(adapter);
+
+	adapter->priv[0] = NULL;
+	adapter->priv[1] = NULL;
+
+	atomic_set(&adapter->tx_pending, 0);
+	atomic_set(&adapter->rx_pending, 0);
+
+	return 0;
+}
+
+
+static void esp_tx_work (struct work_struct *work)
+{
+	process_tx_packet();
+}
+
+static void esp_if_rx_work (struct work_struct *work)
+{
+	/* read inbound packet and forward it to network/serial interface */
+	esp_get_packets(&adapter);
+}
+
+static void deinit_adapter(void)
+{
+	if (adapter.if_rx_workqueue)
+		destroy_workqueue(adapter.if_rx_workqueue);
+
+	if (adapter.tx_workqueue)
+		destroy_workqueue(adapter.tx_workqueue);
+}
+
+static void esp_reset(void)
+{
+	if (resetpin != HOST_GPIO_PIN_INVALID) {
+		/* Check valid GPIO or not */
+		if (!gpio_is_valid(resetpin)) {
+			printk(KERN_WARNING "ESP32: host resetpin (%d) configured is invalid GPIO\n", resetpin);
+			resetpin = HOST_GPIO_PIN_INVALID;
+		}
+		else {
+			printk(KERN_DEBUG "ESP32: Resetpin of Host is %d\n", resetpin);
+			gpio_request(resetpin, "sysfs");
+
+			/* HOST's resetpin set to OUTPUT, HIGH */
+			gpio_direction_output(resetpin, true);
+
+			/* HOST's resetpin set to LOW */
+			gpio_set_value(resetpin, 0);
+			udelay(100);
+
+			/* HOST's resetpin set to INPUT */
+			gpio_direction_input(resetpin);
+
+			printk(KERN_DEBUG "ESP32: Triggering ESP reset.\n");
+		}
+	}
+}
+
+static struct esp_adapter * init_adapter(void)
+{
+	memset(&adapter, 0, sizeof(adapter));
+
+	/* Prepare interface RX work */
+	adapter.if_rx_workqueue = create_workqueue("ESP_IF_RX_WORK_QUEUE");
+
+	if (!adapter.if_rx_workqueue) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.if_rx_work, esp_if_rx_work);
+
+	/* Prepare TX work */
+	adapter.tx_workqueue = create_workqueue("ESP_TX_WORK_QUEUE");
+
+	if (!adapter.tx_workqueue) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.tx_work, esp_tx_work);
+
+	/* Prepare TX work */
+	skb_queue_head_init(&adapter.tx_q);
+	skb_queue_head_init(&adapter.rx_q);
+
+	atomic_set(&adapter.tx_pending, 0);
+	atomic_set(&adapter.rx_pending, 0);
+
+	return &adapter;
+}
+
+
+static int __init esp_init(void)
+{
+	int ret = 0;
+	struct esp_adapter	*adapter;
+
+	/* Reset ESP, Clean start ESP */
+	esp_reset();
+
+	/* Init adapter */
+	adapter = init_adapter();
+
+	if (!adapter)
+		return -EFAULT;
+
+	/* Init transport layer */
+	ret = esp_init_interface_layer(adapter);
+
+	if (ret != 0) {
+		deinit_adapter();
+	}
+
+	return ret;
+}
+
+static void __exit esp_exit(void)
+{
+	esp_deinit_interface_layer();
+	deinit_adapter();
+	if (resetpin != HOST_GPIO_PIN_INVALID) {
+		gpio_free(resetpin);
+	}
+}
+
+module_init(esp_init);
+module_exit(esp_exit);
